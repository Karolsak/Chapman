<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symulator Dynamiczny Generatora Synchronicznego Tr√≥jfazowego</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            padding: 20px;
        }

        .control-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            height: fit-content;
        }

        .section-title {
            font-size: 16px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .parameter-group {
            margin-bottom: 25px;
        }

        .parameter {
            margin-bottom: 15px;
        }

        .parameter label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .parameter input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
            -webkit-appearance: none;
        }

        .parameter input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .parameter input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .parameter .value-display {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 3px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            float: right;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            grid-column: span 2;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #28a745;
            color: white;
        }

        .btn-secondary:hover {
            background: #218838;
        }

        .btn-warning {
            background: #ffc107;
            color: #333;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .solver-select {
            margin-top: 15px;
        }

        .solver-select label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .radio-group {
            display: flex;
            gap: 15px;
        }

        .radio-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: normal;
            cursor: pointer;
        }

        .results-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .results-box {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #667eea;
        }

        .results-box h2 {
            font-size: 18px;
            color: #667eea;
            margin-bottom: 15px;
        }

        .results-text {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.6;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            background: white;
            padding: 15px;
            border-radius: 5px;
        }

        .plots-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .plot-box {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .plot-box h3 {
            font-size: 14px;
            color: #667eea;
            margin-bottom: 10px;
            text-align: center;
        }

        #phasorCanvas {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .base-values {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 11px;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .plots-container {
                grid-template-columns: 1fr;
            }
        }

        .separator {
            height: 2px;
            background: linear-gradient(90deg, transparent, #667eea, transparent);
            margin: 20px 0;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ö° Symulator Dynamiczny Generatora Synchronicznego Tr√≥jfazowego ‚ö°</h1>
            <p>Analiza pracy generatora synchronicznego z symulacjƒÖ dynamicznƒÖ ODE</p>
        </div>

        <div class="main-content">
            <!-- Panel sterowania -->
            <div class="control-panel">
                <div class="section-title">üìä Parametry Generatora</div>

                <div class="base-values">
                    <strong>Warto≈õci bazowe:</strong><br>
                    S<sub>base</sub> = 200 MVA<br>
                    V<sub>base</sub> = 16 kV (L-L)<br>
                    I<sub>base</sub> = 7.217 kA
                </div>

                <div class="parameter-group">
                    <div class="parameter">
                        <label>
                            Reaktancja synchroniczna Xs (p.u.):
                            <span class="value-display" id="xs-value">1.60</span>
                        </label>
                        <input type="range" id="xs" min="0.5" max="3.0" step="0.01" value="1.60">
                    </div>

                    <div class="parameter">
                        <label>
                            Napiƒôcie zaciskowe V (kV L-L):
                            <span class="value-display" id="v-value">15.0</span>
                        </label>
                        <input type="range" id="v-terminal" min="10" max="20" step="0.1" value="15.0">
                    </div>

                    <div class="parameter">
                        <label>
                            SEM wewnƒôtrzna E (kV L-L):
                            <span class="value-display" id="e-value">24.0</span>
                        </label>
                        <input type="range" id="e-internal" min="15" max="35" step="0.1" value="24.0">
                    </div>

                    <div class="parameter">
                        <label>
                            KƒÖt mocy Œ¥ (stopnie):
                            <span class="value-display" id="delta-value">25.0</span>
                        </label>
                        <input type="range" id="delta" min="0" max="90" step="0.5" value="25.0">
                    </div>
                </div>

                <div class="separator"></div>

                <div class="section-title">üîÑ Symulacja Dynamiczna</div>

                <div class="parameter-group">
                    <div class="parameter">
                        <label>
                            Moc mechaniczna Pm (p.u.):
                            <span class="value-display" id="pm-value">0.80</span>
                        </label>
                        <input type="range" id="pm" min="0" max="2" step="0.01" value="0.80">
                    </div>

                    <div class="parameter">
                        <label>
                            Sta≈Ça bezw≈Çadno≈õci H (s):
                            <span class="value-display" id="h-value">3.50</span>
                        </label>
                        <input type="range" id="h-const" min="1" max="10" step="0.1" value="3.5">
                    </div>

                    <div class="parameter">
                        <label>
                            Wsp√≥≈Çczynnik t≈Çumienia D:
                            <span class="value-display" id="d-value">0.050</span>
                        </label>
                        <input type="range" id="d-damp" min="0" max="0.5" step="0.001" value="0.05">
                    </div>

                    <div class="parameter">
                        <label>
                            Czas symulacji (s):
                            <span class="value-display" id="time-value">5.0</span>
                        </label>
                        <input type="range" id="sim-time" min="1" max="20" step="0.5" value="5.0">
                    </div>
                </div>

                <div class="solver-select">
                    <label>Solver ODE:</label>
                    <div class="radio-group">
                        <label>
                            <input type="radio" name="solver" value="rk45" checked>
                            RK45
                        </label>
                        <label>
                            <input type="radio" name="solver" value="euler">
                            Euler
                        </label>
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn-primary" onclick="calculateAll()">üî¢ Oblicz Wszystko</button>
                    <button class="btn-secondary" onclick="runSimulation()">‚ñ∂Ô∏è Symuluj</button>
                    <button class="btn-warning" onclick="toggleAnimation()">üé¨ Animacja</button>
                    <button class="btn-danger" onclick="resetParameters()">üîÑ Reset</button>
                </div>
            </div>

            <!-- Obszar wynik√≥w i wykres√≥w -->
            <div class="results-area">
                <div class="results-box">
                    <h2>üìã Wyniki Oblicze≈Ñ</h2>
                    <div class="results-text" id="results-output">
Kliknij "Oblicz Wszystko" aby rozpoczƒÖƒá analizƒô...
                    </div>
                </div>

                <div class="plots-container">
                    <div class="plot-box">
                        <h3>Charakterystyka Moc-KƒÖt</h3>
                        <div id="power-angle-plot"></div>
                    </div>

                    <div class="plot-box">
                        <h3>Diagram Fazorowy</h3>
                        <canvas id="phasorCanvas"></canvas>
                    </div>

                    <div class="plot-box">
                        <h3>KƒÖt mocy Œ¥ vs Czas</h3>
                        <div id="delta-time-plot"></div>
                    </div>

                    <div class="plot-box">
                        <h3>Odchylenie prƒôdko≈õci œâ vs Czas</h3>
                        <div id="omega-time-plot"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Sta≈Çe bazowe
        const S_BASE = 200e6; // 200 MVA
        const V_BASE_LL = 16e3; // 16 kV
        const V_BASE_PHASE = V_BASE_LL / Math.sqrt(3);
        const I_BASE = S_BASE / (Math.sqrt(3) * V_BASE_LL);
        const Z_BASE = V_BASE_LL * V_BASE_LL / S_BASE;

        // Zmienne globalne
        let results = {};
        let simData = null;
        let animationRunning = false;
        let animationFrame = 0;
        let animationId = null;

        // Inicjalizacja - ustawienie listener√≥w
        document.addEventListener('DOMContentLoaded', function() {
            // Suwaki parametr√≥w generatora
            setupSlider('xs', 'xs-value', 2);
            setupSlider('v-terminal', 'v-value', 1);
            setupSlider('e-internal', 'e-value', 1);
            setupSlider('delta', 'delta-value', 1);

            // Suwaki symulacji
            setupSlider('pm', 'pm-value', 2);
            setupSlider('h-const', 'h-value', 2);
            setupSlider('d-damp', 'd-value', 3);
            setupSlider('sim-time', 'time-value', 1);

            // PoczƒÖtkowe obliczenia
            calculateAll();
        });

        function setupSlider(sliderId, displayId, decimals) {
            const slider = document.getElementById(sliderId);
            const display = document.getElementById(displayId);

            slider.addEventListener('input', function() {
                display.textContent = parseFloat(this.value).toFixed(decimals);
                calculateAll();
            });
        }

        function getParameters() {
            return {
                Xs: parseFloat(document.getElementById('xs').value),
                V_kV: parseFloat(document.getElementById('v-terminal').value),
                E_kV: parseFloat(document.getElementById('e-internal').value),
                delta_deg: parseFloat(document.getElementById('delta').value),
                Pm: parseFloat(document.getElementById('pm').value),
                H: parseFloat(document.getElementById('h-const').value),
                D: parseFloat(document.getElementById('d-damp').value),
                simTime: parseFloat(document.getElementById('sim-time').value)
            };
        }

        function calculateAll() {
            const params = getParameters();

            // Konwersja do jednostek wzglƒôdnych
            const V_pu = (params.V_kV * 1000) / V_BASE_LL;
            const E_pu = (params.E_kV * 1000) / V_BASE_LL;
            const delta_rad = params.delta_deg * Math.PI / 180;

            // Czƒô≈õƒá (a) - PoczƒÖtkowy prƒÖd linii
            const E_complex = {
                re: E_pu * Math.cos(delta_rad),
                im: E_pu * Math.sin(delta_rad)
            };
            const V_complex = { re: V_pu, im: 0 };

            // Ia = (E - V) / (jXs)
            const numerator = {
                re: E_complex.re - V_complex.re,
                im: E_complex.im - V_complex.im
            };
            const denominator = { re: 0, im: params.Xs };

            const Ia_complex = complexDiv(numerator, denominator);
            const Ia_mag = complexMag(Ia_complex);
            const Ia_angle = complexAngle(Ia_complex);
            const Ia_kA = Ia_mag * (I_BASE / 1000);

            // Czƒô≈õƒá (b) - Moc
            const S_complex = complexMult(V_complex, complexConj(Ia_complex));
            const P_pu = S_complex.re;
            const Q_pu = S_complex.im;
            const P_MW = P_pu * (S_BASE / 1e6);
            const Q_MVAR = Q_pu * (S_BASE / 1e6);
            const S_mag = complexMag(S_complex);
            const pf = Math.cos(complexAngle(V_complex) - Ia_angle);

            // Czƒô≈õƒá (c) - PrƒÖd zmniejszony o 25%, ten sam wsp√≥≈Çczynnik mocy
            const Ia_new_mag = 0.75 * Ia_mag;
            const Ia_new_complex = {
                re: Ia_new_mag * Math.cos(Ia_angle),
                im: Ia_new_mag * Math.sin(Ia_angle)
            };

            // E = V + jXs * Ia
            const jXs_Ia_c = complexMult({ re: 0, im: params.Xs }, Ia_new_complex);
            const E_new_c = complexAdd(V_complex, jXs_Ia_c);
            const E_new_c_mag = complexMag(E_new_c);
            const delta_new_c = complexAngle(E_new_c);

            const S_new_c = complexMult(V_complex, complexConj(Ia_new_complex));
            const P_new_c = S_new_c.re;
            const Q_new_c = S_new_c.im;

            // Czƒô≈õƒá (d) - Wsp√≥≈Çczynnik mocy = 1.0
            const Ia_d_complex = { re: Ia_new_mag, im: 0 };

            const jXs_Ia_d = complexMult({ re: 0, im: params.Xs }, Ia_d_complex);
            const E_new_d = complexAdd(V_complex, jXs_Ia_d);
            const E_new_d_mag = complexMag(E_new_d);
            const delta_new_d = complexAngle(E_new_d);

            const S_new_d = complexMult(V_complex, complexConj(Ia_d_complex));
            const P_new_d = S_new_d.re;
            const Q_new_d = S_new_d.im;

            // Zapisz wyniki
            results = {
                a: {
                    Ia_pu: Ia_mag,
                    Ia_kA: Ia_kA,
                    Ia_angle_deg: Ia_angle * 180 / Math.PI,
                    Ia_complex: Ia_complex
                },
                b: {
                    P_pu: P_pu,
                    Q_pu: Q_pu,
                    P_MW: P_MW,
                    Q_MVAR: Q_MVAR,
                    S_pu: S_mag,
                    pf: pf
                },
                c: {
                    E_pu: E_new_c_mag,
                    E_kV_LL: E_new_c_mag * V_BASE_LL / 1000,
                    delta_deg: delta_new_c * 180 / Math.PI,
                    Ia_pu: Ia_new_mag,
                    Ia_kA: Ia_new_mag * (I_BASE / 1000),
                    P_pu: P_new_c,
                    Q_pu: Q_new_c,
                    pf: pf,
                    E_complex: E_new_c,
                    Ia_complex: Ia_new_complex
                },
                d: {
                    E_pu: E_new_d_mag,
                    E_kV_LL: E_new_d_mag * V_BASE_LL / 1000,
                    delta_deg: delta_new_d * 180 / Math.PI,
                    Ia_pu: Ia_new_mag,
                    Ia_kA: Ia_new_mag * (I_BASE / 1000),
                    P_pu: P_new_d,
                    Q_pu: Q_new_d,
                    pf: 1.0,
                    E_complex: E_new_d,
                    Ia_complex: Ia_d_complex
                },
                params: params,
                V_complex: V_complex,
                E_complex: E_complex
            };

            displayResults();
            plotPowerAngle();
            plotPhasorDiagram();
        }

        // Funkcje pomocnicze dla liczb zespolonych
        function complexAdd(a, b) {
            return { re: a.re + b.re, im: a.im + b.im };
        }

        function complexMult(a, b) {
            return {
                re: a.re * b.re - a.im * b.im,
                im: a.re * b.im + a.im * b.re
            };
        }

        function complexDiv(a, b) {
            const denom = b.re * b.re + b.im * b.im;
            return {
                re: (a.re * b.re + a.im * b.im) / denom,
                im: (a.im * b.re - a.re * b.im) / denom
            };
        }

        function complexConj(a) {
            return { re: a.re, im: -a.im };
        }

        function complexMag(a) {
            return Math.sqrt(a.re * a.re + a.im * a.im);
        }

        function complexAngle(a) {
            return Math.atan2(a.im, a.re);
        }

        function displayResults() {
            const r = results;
            let text = '='.repeat(70) + '\n';
            text += 'ANALIZA GENERATORA SYNCHRONICZNEGO TR√ìJFAZOWEGO\n';
            text += '='.repeat(70) + '\n\n';

            text += 'Warto≈õci bazowe:\n';
            text += `  S_base = ${(S_BASE/1e6).toFixed(1)} MVA\n`;
            text += `  V_base (L-L) = ${(V_BASE_LL/1e3).toFixed(1)} kV\n`;
            text += `  V_base (faza) = ${(V_BASE_PHASE/1e3).toFixed(3)} kV\n`;
            text += `  I_base = ${(I_BASE/1e3).toFixed(3)} kA\n`;
            text += `  Z_base = ${Z_BASE.toFixed(3)} Œ©\n\n`;

            text += '-'.repeat(70) + '\n';
            text += 'Czƒô≈õƒá (a): PrƒÖd linii na fazƒô\n';
            text += '-'.repeat(70) + '\n';
            text += `  |Ia| = ${r.a.Ia_pu.toFixed(4)} p.u. = ${r.a.Ia_kA.toFixed(4)} kA\n`;
            text += `  ‚à†Ia = ${r.a.Ia_angle_deg.toFixed(2)}¬∞\n\n`;

            text += '-'.repeat(70) + '\n';
            text += 'Czƒô≈õƒá (b): Moc rzeczywista i bierna\n';
            text += '-'.repeat(70) + '\n';
            text += `  P = ${r.b.P_pu.toFixed(4)} p.u. = ${r.b.P_MW.toFixed(2)} MW\n`;
            text += `  Q = ${r.b.Q_pu.toFixed(4)} p.u. = ${r.b.Q_MVAR.toFixed(2)} MVAR\n`;
            text += `  S = ${r.b.S_pu.toFixed(4)} p.u.\n`;
            text += `  Wsp√≥≈Çczynnik mocy = ${r.b.pf.toFixed(4)} ${r.b.Q_pu > 0 ? 'op√≥≈∫niony' : 'wyprzedzajƒÖcy'}\n\n`;

            text += '-'.repeat(70) + '\n';
            text += 'Czƒô≈õƒá (c): PrƒÖd zmniejszony o 25%, ten sam wsp. mocy\n';
            text += '-'.repeat(70) + '\n';
            text += `  E = ${r.c.E_pu.toFixed(4)} p.u. = ${r.c.E_kV_LL.toFixed(3)} kV (L-L)\n`;
            text += `  Œ¥ = ${r.c.delta_deg.toFixed(2)}¬∞\n`;
            text += `  |Ia| = ${r.c.Ia_pu.toFixed(4)} p.u. = ${r.c.Ia_kA.toFixed(4)} kA\n`;
            text += `  P = ${r.c.P_pu.toFixed(4)} p.u. = ${(r.c.P_pu * S_BASE / 1e6).toFixed(2)} MW\n`;
            text += `  Q = ${r.c.Q_pu.toFixed(4)} p.u. = ${(r.c.Q_pu * S_BASE / 1e6).toFixed(2)} MVAR\n`;
            text += `  Wsp√≥≈Çczynnik mocy = ${r.c.pf.toFixed(4)}\n\n`;

            text += '-'.repeat(70) + '\n';
            text += 'Czƒô≈õƒá (d): Wsp√≥≈Çczynnik mocy = 1.0, ten sam prƒÖd\n';
            text += '-'.repeat(70) + '\n';
            text += `  E = ${r.d.E_pu.toFixed(4)} p.u. = ${r.d.E_kV_LL.toFixed(3)} kV (L-L)\n`;
            text += `  Œ¥ = ${r.d.delta_deg.toFixed(2)}¬∞\n`;
            text += `  |Ia| = ${r.d.Ia_pu.toFixed(4)} p.u. = ${r.d.Ia_kA.toFixed(4)} kA\n`;
            text += `  P = ${r.d.P_pu.toFixed(4)} p.u. = ${(r.d.P_pu * S_BASE / 1e6).toFixed(2)} MW\n`;
            text += `  Q = ${r.d.Q_pu.toFixed(4)} p.u. = ${(r.d.Q_pu * S_BASE / 1e6).toFixed(2)} MVAR\n`;
            text += `  Wsp√≥≈Çczynnik mocy = ${r.d.pf.toFixed(4)}\n\n`;

            text += '='.repeat(70) + '\n';

            document.getElementById('results-output').textContent = text;
        }

        function plotPowerAngle() {
            const params = getParameters();
            const V_pu = (params.V_kV * 1000) / V_BASE_LL;
            const E_pu = (params.E_kV * 1000) / V_BASE_LL;

            // Generuj krzywƒÖ Pe(Œ¥)
            const deltaRange = [];
            const Pe = [];
            for (let d = 0; d <= 180; d += 1) {
                const delta_rad = d * Math.PI / 180;
                deltaRange.push(d);
                Pe.push((E_pu * V_pu / params.Xs) * Math.sin(delta_rad));
            }

            const trace1 = {
                x: deltaRange,
                y: Pe,
                type: 'scatter',
                mode: 'lines',
                name: 'Pe(Œ¥)',
                line: { color: 'blue', width: 2 }
            };

            const traces = [trace1];

            // Dodaj punkty robocze
            if (results.b) {
                traces.push({
                    x: [params.delta_deg],
                    y: [results.b.P_pu],
                    type: 'scatter',
                    mode: 'markers',
                    name: `Punkt (a): Œ¥=${params.delta_deg.toFixed(1)}¬∞`,
                    marker: { color: 'red', size: 12, symbol: 'circle' }
                });
            }

            if (results.c) {
                traces.push({
                    x: [results.c.delta_deg],
                    y: [results.c.P_pu],
                    type: 'scatter',
                    mode: 'markers',
                    name: `Punkt (c): Œ¥=${results.c.delta_deg.toFixed(1)}¬∞`,
                    marker: { color: 'green', size: 12, symbol: 'square' }
                });
            }

            if (results.d) {
                traces.push({
                    x: [results.d.delta_deg],
                    y: [results.d.P_pu],
                    type: 'scatter',
                    mode: 'markers',
                    name: `Punkt (d): Œ¥=${results.d.delta_deg.toFixed(1)}¬∞`,
                    marker: { color: 'blue', size: 12, symbol: 'triangle-up' }
                });
            }

            // Linia Pm
            traces.push({
                x: deltaRange,
                y: Array(deltaRange.length).fill(params.Pm),
                type: 'scatter',
                mode: 'lines',
                name: `Pm = ${params.Pm.toFixed(2)} p.u.`,
                line: { color: 'red', width: 2, dash: 'dash' }
            });

            const layout = {
                xaxis: { title: 'KƒÖt mocy Œ¥ (stopnie)', range: [0, 180] },
                yaxis: { title: 'Moc elektryczna Pe (p.u.)' },
                margin: { l: 50, r: 20, t: 20, b: 50 },
                height: 300,
                showlegend: true,
                legend: { x: 0.02, y: 0.98, font: { size: 10 } }
            };

            Plotly.newPlot('power-angle-plot', traces, layout, { responsive: true });
        }

        function plotPhasorDiagram() {
            const canvas = document.getElementById('phasorCanvas');
            const ctx = canvas.getContext('2d');

            // Ustawienia canvas
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = Math.min(canvas.width, canvas.height) / 4;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Osie
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();

            if (!results.V_complex) return;

            const params = getParameters();

            // Rysuj fazory dla wszystkich warunk√≥w
            const conditions = [
                { key: 'a', color: 'red', label: '(a)' },
                { key: 'c', color: 'green', label: '(c)' },
                { key: 'd', color: 'blue', label: '(d)' }
            ];

            conditions.forEach(cond => {
                if (!results[cond.key]) return;

                const V = results.V_complex;
                const E = results[cond.key].E_complex;
                const Ia = results[cond.key].Ia_complex;

                // Rysuj V (tylko raz)
                if (cond.key === 'a') {
                    drawArrow(ctx, centerX, centerY,
                             centerX + V.re * scale,
                             centerY - V.im * scale,
                             'black', 3, 'V');
                }

                // Rysuj E
                drawArrow(ctx, centerX, centerY,
                         centerX + E.re * scale,
                         centerY - E.im * scale,
                         cond.color, 2, `E ${cond.label}`);

                // Rysuj Ia (przeskalowany)
                const Ia_scale = 0.5;
                drawArrow(ctx, centerX, centerY,
                         centerX + Ia.re * scale * Ia_scale,
                         centerY - Ia.im * scale * Ia_scale,
                         cond.color, 1.5, '', true);

                // Rysuj jXs*Ia
                const jXsIa = complexMult({ re: 0, im: params.Xs }, Ia);
                drawArrow(ctx,
                         centerX + V.re * scale,
                         centerY - V.im * scale,
                         centerX + V.re * scale + jXsIa.re * scale,
                         centerY - V.im * scale - jXsIa.im * scale,
                         cond.color, 1, '', true);
            });

            // Legenda
            ctx.font = '11px Arial';
            ctx.fillStyle = 'black';
            let y = 20;
            ctx.fillText('Diagram fazorowy:', 10, y);
            y += 20;
            conditions.forEach(cond => {
                ctx.fillStyle = cond.color;
                ctx.fillText(`‚ñ† Warunek ${cond.label}`, 10, y);
                y += 20;
            });
        }

        function drawArrow(ctx, x1, y1, x2, y2, color, width, label, dashed = false) {
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = width;

            if (dashed) {
                ctx.setLineDash([5, 5]);
            } else {
                ctx.setLineDash([]);
            }

            // Linia
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            // Grot strza≈Çki
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const headLen = 10;

            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI / 6),
                      y2 - headLen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI / 6),
                      y2 - headLen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();

            // Etykieta
            if (label) {
                ctx.font = 'bold 12px Arial';
                ctx.fillText(label, x2 + 5, y2 - 5);
            }

            ctx.setLineDash([]);
        }

        function runSimulation() {
            const params = getParameters();
            const V_pu = (params.V_kV * 1000) / V_BASE_LL;
            const E_pu = (params.E_kV * 1000) / V_BASE_LL;
            const delta0 = params.delta_deg * Math.PI / 180;

            const solverType = document.querySelector('input[name="solver"]:checked').value;
            const dt = 0.01;
            const tMax = params.simTime;
            const steps = Math.floor(tMax / dt);

            let t = [0];
            let delta = [delta0];
            let omega = [0];

            const omega_base = 2 * Math.PI * 60; // 60 Hz
            const M = 2 * params.H / omega_base;

            if (solverType === 'euler') {
                // Metoda Eulera
                for (let i = 0; i < steps; i++) {
                    const Pe = (E_pu * V_pu / params.Xs) * Math.sin(delta[i]);
                    const dOmega = (params.Pm - Pe - params.D * omega[i]) / M;
                    const dDelta = omega[i];

                    omega.push(omega[i] + dt * dOmega);
                    delta.push(delta[i] + dt * dDelta);
                    t.push(t[i] + dt);
                }
            } else {
                // Metoda RK4 (uproszczona wersja RK45)
                for (let i = 0; i < steps; i++) {
                    const y = [delta[i], omega[i]];
                    const k1 = derivatives(y, params.Pm, E_pu, V_pu, params.Xs, M, params.D);
                    const k2 = derivatives(
                        [y[0] + 0.5 * dt * k1[0], y[1] + 0.5 * dt * k1[1]],
                        params.Pm, E_pu, V_pu, params.Xs, M, params.D
                    );
                    const k3 = derivatives(
                        [y[0] + 0.5 * dt * k2[0], y[1] + 0.5 * dt * k2[1]],
                        params.Pm, E_pu, V_pu, params.Xs, M, params.D
                    );
                    const k4 = derivatives(
                        [y[0] + dt * k3[0], y[1] + dt * k3[1]],
                        params.Pm, E_pu, V_pu, params.Xs, M, params.D
                    );

                    delta.push(y[0] + (dt / 6) * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]));
                    omega.push(y[1] + (dt / 6) * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1]));
                    t.push(t[i] + dt);
                }
            }

            // Konwersja delta na stopnie
            const deltaDeg = delta.map(d => d * 180 / Math.PI);

            simData = { t, delta: deltaDeg, omega };

            plotSimulationResults();

            alert(`Symulacja zako≈Ñczona!\nSolver: ${solverType.toUpperCase()}\nCzas: 0 - ${tMax} s`);
        }

        function derivatives(y, Pm, E, V, Xs, M, D) {
            const delta = y[0];
            const omega = y[1];
            const Pe = (E * V / Xs) * Math.sin(delta);

            return [
                omega,
                (Pm - Pe - D * omega) / M
            ];
        }

        function plotSimulationResults() {
            if (!simData) return;

            // Wykres delta vs czas
            const trace1 = {
                x: simData.t,
                y: simData.delta,
                type: 'scatter',
                mode: 'lines',
                name: 'Œ¥(t)',
                line: { color: 'blue', width: 2 }
            };

            const layout1 = {
                xaxis: { title: 'Czas (s)' },
                yaxis: { title: 'KƒÖt mocy Œ¥ (stopnie)' },
                margin: { l: 50, r: 20, t: 20, b: 50 },
                height: 300,
                showlegend: false
            };

            Plotly.newPlot('delta-time-plot', [trace1], layout1, { responsive: true });

            // Wykres omega vs czas
            const trace2 = {
                x: simData.t,
                y: simData.omega,
                type: 'scatter',
                mode: 'lines',
                name: 'œâ(t)',
                line: { color: 'red', width: 2 }
            };

            const layout2 = {
                xaxis: { title: 'Czas (s)' },
                yaxis: { title: 'Odchylenie prƒôdko≈õci œâ (rad/s)' },
                margin: { l: 50, r: 20, t: 20, b: 50 },
                height: 300,
                showlegend: false
            };

            Plotly.newPlot('omega-time-plot', [trace2], layout2, { responsive: true });
        }

        function toggleAnimation() {
            if (!simData) {
                alert('Najpierw uruchom symulacjƒô!');
                return;
            }

            if (animationRunning) {
                stopAnimation();
            } else {
                startAnimation();
            }
        }

        function startAnimation() {
            animationRunning = true;
            animationFrame = 0;
            document.querySelector('.btn-warning').textContent = '‚è∏Ô∏è Stop';
            animate();
        }

        function stopAnimation() {
            animationRunning = false;
            document.querySelector('.btn-warning').textContent = 'üé¨ Animacja';
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }

        function animate() {
            if (!animationRunning) return;

            if (animationFrame >= simData.t.length) {
                animationFrame = 0; // Zapƒôtlenie
            }

            // Aktualizuj wykresy z markerem
            updatePlotsWithMarker(animationFrame);

            animationFrame += 2; // Szybko≈õƒá animacji
            animationId = requestAnimationFrame(animate);
        }

        function updatePlotsWithMarker(frame) {
            // Wykres delta
            const trace1 = {
                x: simData.t,
                y: simData.delta,
                type: 'scatter',
                mode: 'lines',
                line: { color: 'blue', width: 2 }
            };

            const marker1 = {
                x: [simData.t[frame]],
                y: [simData.delta[frame]],
                type: 'scatter',
                mode: 'markers',
                marker: { color: 'red', size: 10 }
            };

            const layout1 = {
                xaxis: { title: 'Czas (s)' },
                yaxis: { title: 'KƒÖt mocy Œ¥ (stopnie)' },
                margin: { l: 50, r: 20, t: 20, b: 50 },
                height: 300,
                showlegend: false
            };

            Plotly.newPlot('delta-time-plot', [trace1, marker1], layout1, { responsive: true });

            // Wykres omega
            const trace2 = {
                x: simData.t,
                y: simData.omega,
                type: 'scatter',
                mode: 'lines',
                line: { color: 'red', width: 2 }
            };

            const marker2 = {
                x: [simData.t[frame]],
                y: [simData.omega[frame]],
                type: 'scatter',
                mode: 'markers',
                marker: { color: 'blue', size: 10 }
            };

            const layout2 = {
                xaxis: { title: 'Czas (s)' },
                yaxis: { title: 'Odchylenie prƒôdko≈õci œâ (rad/s)' },
                margin: { l: 50, r: 20, t: 20, b: 50 },
                height: 300,
                showlegend: false
            };

            Plotly.newPlot('omega-time-plot', [trace2, marker2], layout2, { responsive: true });
        }

        function resetParameters() {
            document.getElementById('xs').value = 1.60;
            document.getElementById('v-terminal').value = 15.0;
            document.getElementById('e-internal').value = 24.0;
            document.getElementById('delta').value = 25.0;
            document.getElementById('pm').value = 0.80;
            document.getElementById('h-const').value = 3.5;
            document.getElementById('d-damp').value = 0.05;
            document.getElementById('sim-time').value = 5.0;

            document.getElementById('xs-value').textContent = '1.60';
            document.getElementById('v-value').textContent = '15.0';
            document.getElementById('e-value').textContent = '24.0';
            document.getElementById('delta-value').textContent = '25.0';
            document.getElementById('pm-value').textContent = '0.80';
            document.getElementById('h-value').textContent = '3.50';
            document.getElementById('d-value').textContent = '0.050';
            document.getElementById('time-value').textContent = '5.0';

            document.querySelector('input[name="solver"][value="rk45"]').checked = true;

            calculateAll();
        }

        // Responsywno≈õƒá - aktualizacja przy zmianie rozmiaru okna
        window.addEventListener('resize', function() {
            if (results.b) {
                plotPowerAngle();
                plotPhasorDiagram();
            }
            if (simData) {
                plotSimulationResults();
            }
        });
    </script>
</body>
</html>
